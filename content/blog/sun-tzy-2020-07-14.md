---
title: "Sun Tzu's wisdom in Software Development"
date: 2020-07-14T12:00:00+01:00
draft: false
image: "/images/suntzu.jpeg"

# meta description
description: "Turning dualism into dialectical monism"
# taxonomies
tags:
  - "phylosophy, technology"

# post type
type: "blog"
---
These are some thoughts that came to me after reading [this summary of "Deciphering Sun Tzu: How to read The Art of War"](https://www.evernote.com/shard/s199/client/snv?noteGuid=021bce7d-033e-408f-a092-2da6615e8826&noteKey=7002479436dada5f&sn=https%3A%2F%2Fwww.evernote.com%2Fshard%2Fs199%2Fsh%2F021bce7d-033e-408f-a092-2da6615e8826%2F7002479436dada5f&title=Deciphering%2BSun%2BTzu).

Some of the ideas that Sun Tzu expresses are close to Taoism. The one that got me interested is about "turning dualism into dialectical monism".

In western philosophy, two contradicting options exclude each other - there can be either A or non-A. Eastern philosophy is more flexible than that. A and non-A can coexist in different proportions, can interchange each other, and can be even complimenting each other.

There is an example of attack and defense in a battle. According to the principle of yin-yang, they are not contradicting strategies but complimenting each other. A wise general has to keep in mind both of them, adjusting their balance dynamically. Depending on the situation, one becomes more important than the other, but the balance can change at any moment.

If you don't keep the balance, then "anything bears its own seeds of destruction when overextends". Focus for too long on the attack or the defense exclusively - and you are going to lose the battle.

This article made me think about discussions we often have in Software Development. Many times I saw people arguing about choosing between two options, like:

* TDD vs no tests at all
* clean code vs dirty hacks;
* microservices vs monoliths;
* long-term goals vs short-term benefits;
* new and hyped tech vs old and battle-tested tech;
* statically typed languages vs dynamically typed languages;
* face-to-face communication vs strict processes;
* custom process per team vs generic process for the whole company;
* teaching someone how to fix vs quickly fixing yourself;
* compact code vs readable code;
* Agile vs Waterfall;
* SAFe vs LeSS;
* OOP vs FP;
* and so on, and so on.

We don't become better developers by "knowing the right answer". We get better by learning the pros and cons of both options. The best discussions start when the question is not "or", but "when": When do you prefer option A? When should you switch to non-A?

Another thing is Sun Tzu's answer on how to get better at answering "when" questions. It is not by doing actions, but by making observations - knowing yourself, knowing the environment, knowing what events lead to which consequences. The more attentive and conscious you are, the more open you are to new experience, the better you are at maintaining the dynamic balance, the closer you are to the victory.

_Photo by <a href="https://unsplash.com/@claybanks?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Clay Banks</a> on <a href="https://unsplash.com/s/photos/chinese?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>_